{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"A scalable, harmonized, and cloud-friendly ecosystem for spatial transcriptomics data","text":""},{"location":"#overview","title":"Overview","text":"<p>Spatial transcriptomics (ST) technologies have revolutionized our ability to map molecular features with remarkable resolution\u2014down to cellular and subcellular levels. </p> <p>While the rapid development of sequencing-based platforms (e.g., Seq-Scope, Stereo-seq, Pixel-seq, 10x Visium HD) and imaging-based platforms (e.g., 10x Xenium, Vizgen MERSCOPE, CosMx SMI) has led to an explosion in the production of ST datasets across diverse tissues and species, this platform diversity has also introduced heterogeneous data formats and metadata schemas, which further obstruct efforts toward standardized data ingestion, cross-platform harmonization, and reproducible analytical workflows.</p> <p>To address this challenge, we introduce a scalable, harmonized, and cloud-friendly ecosystem for spatial transcriptomics data across platforms, composed of two components:</p> <ul> <li>cartloader \u2013 a harmonized, scalable pipeline for high-resolution spatial omics data processing and analysis with retaining the original resolution.</li> <li>cartostore \u2013 an open-access, cloud-hosted repository for dataset sharing and visualization.</li> </ul> <p>Together, this system should provide a unified solution for working with raw pixel-level spatial omics data\u2014without sacrificing resolution or reproducibility.</p>"},{"location":"#cartloader-a-scalable-spatial-transcriptomics-pipeline","title":"Cartloader: A Scalable Spatial Transcriptomics Pipeline","text":"<p>This document introduces <code>cartloader</code>, which is the core engine of our ecosystem. It provides a modular, reproducible tool to harmonize, integrate, analyze, and visualize raw high-resolution ST data across platforms. Usage examples are provided in the Get Started. Detailed descriptions of its workflow, inputs, outputs, and parameters are provided in the Reference Pages.</p> <p>Key Features</p> <ul> <li>Cross-Platform Harmonization: Converts raw spatial gene expression (SGE) data from diverse ST platforms into a unified format, enabling consistent downstream processing.</li> <li>Spatial Factor Inference: Applies FICTURE to infer spatial factors directly from pixel-level data, capturing biological patterns without requiring cell segmentation.</li> <li>Multi-Modal Alignment: Aligns and overlays histology images to SGE data so all layers (histology, SGE, and histological images) share a common coordinate system for pixel-accurate comparisons.</li> <li>Cloud-Friendly Outputs: Produces compact, geospatially-indexed data formats suitable for web visualization and cloud storage.</li> <li>Batch Integration and Sample Stitching: Supports joint analysis and SGE stitching across samples or platforms to reveal shared or differential features across tissues.</li> <li>Modular and Reproducible Workflow: Orchestrates all steps through a Makefile-based system to ensure scalability, transparency, and reproducibility.</li> </ul>"},{"location":"#cartostore-cloud-access-and-visualization","title":"Cartostore: Cloud Access and Visualization","text":"<p>As a natural companion to <code>cartloader</code>, cartostore hosts the output of processed datasets for public access and exploration. Designed for scalability and interoperability, cartostore uses spatially indexed formats like PMTiles to support interactive visualization and seamless integration.</p> <p>Explore the Cartostore documentation to learn more about dataset access and how to contribute.</p>"},{"location":"#citations","title":"Citations:","text":"<ul> <li>FICTURE: doi.org/10.1038/s41592-024-02415-2</li> </ul>"},{"location":"installation/","title":"Installation Guide","text":"<p>This is an instruction to set up the required environment, install necessary dependencies, and install <code>cartloader</code>.</p>"},{"location":"installation/#1-dependencies","title":"1. Dependencies","text":"<p>To ensure full functionality of <code>cartloader</code>, the following dependencies must be installed:</p>"},{"location":"installation/#11-system-dependencies","title":"1.1 System Dependencies","text":"<p>Ensure the following command-line tools are available on your system: - <code>gzip</code> - <code>sort</code> - <code>bgzip</code> - <code>tabix</code> </p>"},{"location":"installation/#12-external-tools-utilities","title":"1.2 External Tools &amp; Utilities","text":"<p>The following external tools and utilities are required for handling spatial data and file processing. Some of these are included as submodules within the repository.</p> <p>Python &amp; Related Packages: - <code>python</code> (<code>cartloader</code> has been tested for compatibility with Python v3.10, and v3.13.1) - <code>parquet-tools</code></p> <p>External Tools (Included in submodules) - <code>punkst</code> ((the latest and more efficient implementation of FICTURE) - <code>spatula</code> - <code>tippecanoe</code> - <code>magick</code> - <code>go-pmtiles</code></p> <p>Geospatial Data Handling: - <code>gdal</code></p> <p>Cloud &amp; CLI Tools: - <code>aws-cli</code></p>"},{"location":"installation/#2-setting-up-the-environment-using-conda","title":"2. Setting Up the Environment using <code>conda</code>","text":"<p>We recommended to use <code>conda</code> to manage dependencies efficiently and avoid conflicts.</p>"},{"location":"installation/#21-installing-conda","title":"2.1 Installing <code>conda</code>","text":"<p>If <code>conda</code> is not installed, download and install Miniconda or Anaconda.</p> <p>Here is an example to install <code>Miniconda3</code> on Linux.</p> <pre><code>env_dir=/path/to/your/directory/hosting/tools/      ## replace `/path/to/your/directory/hosting/tools/` by the path to your tool directory\ncd $env_dir\n\nwget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh\nbash Miniconda3-latest-Linux-x86_64.sh\n</code></pre>"},{"location":"installation/#22-creating-an-environment","title":"2.2 Creating an Environment","text":"<p>Create a dedicated Conda environment for <code>cartloader</code>:</p> <pre><code>conda_env=cartenv               # replace cartenv with the name of your conda environment\npython_version=3.13.1           # replace 3.13.1 with the version you prefer\n\nconda create -n cartenv python=$python_version\nconda activate cartenv\n</code></pre>"},{"location":"installation/#23-installing-dependencies","title":"2.3 Installing Dependencies","text":"<p>Once inside the environment, install the required dependencies:</p> <pre><code>conda install -c conda-forge gdal aws-cli imagemagick parquet-tools\n</code></pre>"},{"location":"installation/#3-installing-cartloader","title":"3. Installing <code>cartloader</code>","text":"<p>Clone the repository and install it:</p> <pre><code>cd $env_dir\ngit clone git@github.com:seqscope/cartloader.git\ncd cartloader\npip install -e ./                                   # (TODO) Install in editable mode for developmentartloader\n\n# Install its requirements:\npip install -r ./requirements.txt\n</code></pre>"},{"location":"installation/#4-installing-submodules","title":"4. Installing Submodules","text":""},{"location":"installation/#41-installing-spatula","title":"4.1 Installing <code>spatula</code>","text":"<p>Install <code>spatula</code> with its dependencies from the submodules directory:</p> <pre><code>cd ${env_dir}/cartloader/submodules\nbash -x build.sh\ncd ..\n</code></pre>"},{"location":"installation/#42-installing-punkst","title":"4.2 Installing <code>punkst</code>","text":"<p>Install <code>punkst</code> toolkit to use <code>FICTURE</code> (Si et al., Nature Methods 2024).</p> <p><code>FICTURE</code> is a segmentation-free method that infers latent spatial factors\u2014coherent spatial patterns of gene activity\u2014that correspond to underlying transcriptional programs or tissue structures. These factors can then be projected back to the pixel level. Although <code>FICTURE</code> is built on a Latent Dirichlet Allocation (LDA) framework by default, it is also compatible with clustering outputs from external tools like <code>Seurat</code> for pixel-level projection.</p> <p>The <code>punkst</code> toolkit is a streamlined implementation of the <code>FICTURE</code>, designed for improved computational efficiency and scalability while producing results equivalent to the original <code>FICTURE</code>.</p> <p>Please following the <code>punkst</code> installation guide to install <code>punkst</code></p>"},{"location":"installation/#43-installing-tippecanoe","title":"4.3 Installing <code>tippecanoe</code>","text":"<pre><code>cd ${env_dir}/cartloader/submodules/tippecanoe\nmake -j\nmake install  # Requires root access. \n              # Alternatively, run `make install PREFIX=${env_dir}/cartloader/submodules/tippecanoe/` to specify a custom installation directory.\n</code></pre>"},{"location":"installation/#44-installing-go-pmtiles","title":"4.4 Installing <code>go-pmtiles</code>","text":"<p>An easy way to install <code>go-pmtiles</code> is to download a release from the official website and decompress it. This will return a <code>pmtiles</code> bin file ready for use.</p> <p>Here is an example of its installation:</p> <pre><code>cd ${env_dir}\nwget https://github.com/protomaps/go-pmtiles/releases/download/v1.28.0/go-pmtiles_1.28.0_Linux_x86_64.tar.gz ./\ntar zxvf ./go-pmtiles_1.28.0_Linux_x86_64.tar.gz\n</code></pre>"},{"location":"installation/#45-installing-imagemagic","title":"4.5 Installing ImageMagic","text":"<p>If you have already installed ImageMagic when setting conda environment, skip this step.</p> <pre><code>cd ${env_dir}/cartloader/submodules/ImageMagick\n./configure     # Alternatively, run `./configure --prefix=${env_dir}/cartloader/submodules/ImageMagick`.\nmake \nmake install \n</code></pre>"},{"location":"installation/#5-verifying-the-installation","title":"5. Verifying the Installation","text":"<p>To confirm the package is installed correctly, run:</p> <pre><code>python -c \"import cartloader; print('cartloader installed successfully!')\"\n</code></pre>"},{"location":"showcase/exampledat/","title":"A Quick Start","text":""},{"location":"showcase/exampledat/#overview","title":"Overview","text":"<p>This page provides a quick-start example with a small dataset to help users verify their installation and get familiar with <code>cartloader</code> and the <code>cartostore</code> workflow.</p> <p>The workflow consists of four major stages:</p> <ol> <li>SGE Harmonization \u2014 prepares raw SGE into a harmonized format.</li> <li>FICTURE Analysis \u2014 computes factor embeddings and visualizations via <code>punkst</code>.</li> <li>Cartloader Compilation \u2014 generates web-compatible tiles using <code>tippecanoe</code> and <code>pmtiles</code>.</li> <li>AWS Upload \u2014 places results into an AWS S3 bucket for sharing via <code>cartostore</code>.</li> </ol>"},{"location":"showcase/exampledat/#input-data","title":"Input Data","text":"<p>Input Data Requirement:</p> <p>Input data should be a transcript-indexed SGE containing at least:</p> <ul> <li>Spatial coordinates (X coordinates, Y coordinates)</li> <li>Feature metadata (gene symbols)</li> <li>Expression Counts</li> </ul> <p>In this guide, we use an example SGE derived from mouse hippocampus (<code>Input.tsv.gz</code>):</p> <p>Data Source: The original data, generated from a full coronal brain slice via SeqScope, was spatially masked to extract a subregion contains hippocampus, returning a compressed TSV (<code>input.tsv.gz</code>).</p> <p>Data format:   <pre><code>#lane  tile  X        Y        gene_id             gene     gn  gt  spl  unspl  ambig\n1      1     7800145  3509475  ENSMUSG00000067786  Nnat     1   1   1    0      0\n1      1     7800145  3510101  ENSMUSG00000020315  Sptbn1   1   1   1    0      0\n1      1     7800145  3520153  ENSMUSG00000024845  Tmem134  1   1   1    0      0\n</code></pre></p> <ul> <li><code>lane</code> and <code>tile</code>: the lane and tile information</li> <li><code>X</code> and <code>Y</code>: Spatial coordinates (pixels, depending on units-per-um)</li> <li><code>gene_id</code>: Ensembl or platform-specific gene identifier (optional)</li> <li><code>gene</code>: Gene Name</li> <li><code>gn</code>, <code>gt</code>, <code>spl</code>, <code>unspl</code>, and <code>ambig</code>: Count per gene per pixel for each genomic feature, in the order of Gene, GeneFull, Spliced, Unspliced, and Ambiguous.<ul> <li><code>gn</code>: represents unique, confidently mapped transcript count (\"gene name\"-based);</li> <li><code>gt</code>: denotes total transcript count assigned to gene (includes ambiguities).</li> </ul> </li> </ul> <p>Data Access: The input example data can be dowloaded via AWS? Zenodo?</p> <pre><code>\n</code></pre>"},{"location":"showcase/exampledat/#process","title":"Process","text":""},{"location":"showcase/exampledat/#set-up-the-environment","title":"Set Up the Environment","text":"<pre><code># Define paths to required binaries and resources\nspatula=/path/to/spatula/binary         # path to spatula executable\npunkst=/path/to/punkst/binary           # path to FICTURE2/punkst executable\ntippecanoe=/path/to/tippecanoe/binary   # path to tippecanoe executable\npmtiles=/path/to/pmtiles/binary         # path to pmtiles executable\naws=/path/to/aws/cli/binary             # path to AWS CLI binary\n\n# (Optional) Define path to color map. \ncmap=/path/to/color/map                 # Path to the fixed color map used for rendering. cartloader provides a fixed color map at cartloader/assets/fixed_color_map_256.tsv.\n\n# AWS S3 target location for cartostore\nAWS_BUCKET=\"EXAMPLE_AWS_BUCKET\"         # replace this with your actual S3 bucket name\n\n# Unique identifier for your dataset\nDATA_ID=\"seqscope_hippo\"                # change this to reflect your dataset name\n</code></pre>"},{"location":"showcase/exampledat/#sge-harmonization","title":"SGE Harmonization","text":"<p>Convert the raw input to the unified SGE format. See more details in SGE Harmonization.</p> <pre><code>cartloader sge_convert \\\n    --makefn sge_convert.mk \\           # (optional) file name of the output make file\n    --platform generic \\                # use the 'generic' platform parser (adapt as needed for others like 10x_visium_hd, seqscope etc.)\n    --in-csv ./input.tsv.gz \\           # path to the input.tsv.gz containing raw transcript-indexed SGE\n    --csv-colnames-count gn \\           # column name for expression counts in the input file (use 'gn' for unique counts in the example data)\n    --csv-colname-feature-name gene \\   # column name for gene symbols in the input file\n    --units-per-um 1000.0 \\             # scale to convert coordinates to microns (the example input data is in nanometers, use 1000.0 since 1000 nm = 1 \u00b5m)\n    --out-dir ./sge \\                   # path to output directory where the unified SGE will be saved\n    --colnames-count count  \\           # output column name for expression count\n    --sge-visual \\                      # (optional) enable SGE visualization step\n    --spatula ${spatula} \\              # (optional) path to the spatula binary\n    --n-jobs 10                         # (optional) number of parallel jobs for processing\n</code></pre>"},{"location":"showcase/exampledat/#ficture-analysis","title":"<code>FICTURE</code> analysis","text":"<p>Compute spatial factors using <code>punkst</code> (FICTURE2 mode). See more details in FICTURE Analysis. <pre><code>cartloader run_ficture2 \\\n    --makefn run_ficture2.mk \\                          # (optional) file name of the output make file\n    --main \\                                            # run all five steps in `run_ficture2`\n    --in-transcript ./sge/transcripts.unsorted.tsv.gz \\ # path to input transcript-level SGE file\n    --in-feature ./sge/feature.clean.tsv.gz \\           # (optional) path to input feature file\n    --in-minmax ./sge/coordinate_minmax.tsv \\           # (optional) path to input minmax file\n    --cmap-file ${cmap} \\                               # (optional) path to input color map file\n    --colname-count count \\                             # column name for expression count in the input transcript-level SGE file\n    --exclude-feature-regex '^(mt-.*$|Gm\\d+$)' \\        # regex pattern to exclude features (removing mitochondrial and predicted genes in the example analysis)\n    --out-dir ./ficture2 \\                              # path to output directory\n    --width 18 \\                                        # LDA training hexagon width (comma-separated if multiple widths are applied)\n    --n-factor 6,12,18 \\                                # number of factors in LDA training (comma-separated if multiple n-factor are applied)\n    --spatula ${spatula} \\                              # (optional) path to the spatula binary\n    --ficture2 ${punkst} \\                              # (optional) path to the punkst directory\n    --n-jobs 10  \\                                      # (optional) number of parallel jobs \n    --threads 10                                        # (optional) number of threads per job\n</code></pre></p>"},{"location":"showcase/exampledat/#cartloader-compilation","title":"<code>cartloader</code> Compilation","text":"<p>Generate pmtiles and web-compatible tile directories. See more details in cartloader Compilation.</p> <pre><code>cartloader run_cartload2 \\\n    --makefn run_cartload2.mk \\         # (optional) file name of the output make file\n    --fic-dir ./ficture2 \\              # path to input directory containing FICTURE2 output\n    --out-dir ./cartload2 \\             # path to output directory for PMTiles and web tiles\n    --id ${DATA_ID} \\                   # dataset ID used for naming outputs and metadata\n    --colname-count count \\             # column name for expression count in the input FICTURE2 output\n    --spatula ${spatula} \\              # (optional) path to the spatula binary\n    --pmtiles ${pmtiles} \\              # (optional) path to the pmtiles binary\n    --tippecanoe ${tippecanoe} \\        # (optional) path to the tippecanoe binary\n    --n-jobs 10 \\                       # (optional) number of parallel jobs\n    --threads 10                        # (optional) number of threads per job\n</code></pre>"},{"location":"showcase/exampledat/#upload-to-aws","title":"Upload to AWS","text":"<p>Copy the generated cartloader outputs to your designated AWS S3 catalog path:</p> <pre><code>cartloader upload_aws_by_catalog \\\n    --in-dir ./cartload2 \\                      # path to the input directory containing the cartloader compilation output\n    --s3-dir \"s3://${AWS_BUCKET}/${DATA_ID}\" \\  # path to s3 directory hosting those files\n    --aws ${aws} \\                              # (optional) path to the aws binary\n    --n-jobs 10                                 # (optional) number of parallel jobs\n</code></pre>"},{"location":"showcase/intro/","title":"Getting Started with <code>cartloader</code>","text":"<p>We offer a series of tutorials to help users get started with <code>cartloader</code>. For a more detailed explanation of each step in the pipeline, refer to our Reference Pages.</p> <p>Requirement</p> <p>Before getting started, please ensure that cartloader and all prerequisites are installed by following the Installation guide.</p>"},{"location":"showcase/intro/#quick-start-with-a-single-sge-dataset","title":"Quick Start with a Single SGE Dataset","text":"<p>If you're new to the toolkit, we recommend beginning with the Quick Start tutorial. It uses a small mouse hippocampus dataset generated by SeqScope and walks through the full pipeline:  </p> <ol> <li>SGE harmonization</li> <li>Spatial factor inference with <code>FICTURE</code> </li> <li>Packaging outputs using <code>cartloader</code> for deployment.</li> </ol> <p>This hands-on example is designed to help you validate your setup and get comfortable with each stage of the workflow.</p>"},{"location":"step_by_step/run_cartload2/","title":"Spatial Asset Packaging","text":""},{"location":"step_by_step/run_cartload2/#overview","title":"Overview","text":"<p>Following spatial factor inference via FICTURE analysis, <code>cartloader</code> offers the <code>run_cartload2</code> module package SGE data and spatial factor output from FICTURE analysis into standardized, spatially indexed, and storage-efficient PMTiles, a web-native tiling format. These PMTiles outputs are optimized for downstream analysis, interactive web visualization (e.g., in CartoScope), and data sharing across platforms.</p>"},{"location":"step_by_step/run_cartload2/#requirements","title":"Requirements","text":"<ul> <li>A completed FICTURE run (pixel-level decoding outputs) (from <code>run_ficture2</code>)</li> <li>A metadata file describing the input-output structure (<code>ficture.params.json</code>)</li> <li>Pre-installed CLI tools: <code>tippecanoe</code>, <code>gdal_translate</code>, <code>gdaladdo</code>, <code>pmtiles</code>, <code>spatula</code>, <code>gzip</code></li> </ul>"},{"location":"step_by_step/run_cartload2/#example-usage","title":"Example Usage","text":"<pre><code>cartloader run_cartload2 \\\n    --makefn run_cartload2.mk \\\n    --fic-dir /path/to/run_ficture2/results \\\n    --out-dir /path/to/output/directory \\\n    --id dataset_id \\                            ## replace dataset_id with the id for this dataset\n    --colname-count count \\\n    --n-jobs 20  \\\n    --threads 20 \\\n    --spatula /path/to/spatula/binary \\\n    --pmtiles /path/to/pmtiles/binary \\\n    --tippecanoe /path/to/tippecanoe/binary\n</code></pre>"},{"location":"step_by_step/run_cartload2/#actions","title":"Actions","text":"<p>Specifically, it will perform all the following steps:</p> <ul> <li>Converts transcript-level SGE to raster-format PMTiles.</li> <li>Converts topic proportions (.results.tsv.gz) into vector PMTiles for spatial factors.</li> <li>Processes each decoded pixel-level output to generate raster PMTiles for visual overlays.</li> <li>Create a joined molecule-feature matrix by joining decoded pixel-level spatial factors from FICTURE with transcript-level molecules from the original SGE based on spatial proximity.</li> <li>Converts the joined molecule-feature matrix into storage-efficient, multi-feature PMTiles.</li> <li>Generates a JSON file listing all FICTURE assets and a YAML catalog describing the final visualization layers.</li> </ul>"},{"location":"step_by_step/run_cartload2/#parameters","title":"Parameters","text":"<p>The following outlines the minimum required parameters for running spatial asset packaging. </p> <p>For auxiliary parameters, we recommend using the default values unless you possess a thorough understanding of <code>run_cartload2</code>. For further details, refer to the collapsible sections below or run:</p> <pre><code>cartloader run_cartload2 --help\n</code></pre>"},{"location":"step_by_step/run_cartload2/#inputoutput-parameters","title":"Input/Output Parameters","text":"<ul> <li><code>--fic-dir</code> (str): Path to the input directory containing FICTURE output.</li> <li><code>--out-dir</code> (str): Path to the output directory for storing generated assets.</li> </ul>"},{"location":"step_by_step/run_cartload2/#dataset-id-and-descriptions","title":"Dataset ID and Descriptions","text":"<ul> <li><code>--id</code> (str): Unique identifier for the output asset set.</li> <li><code>--title</code> (str): Optional title for the output assets.</li> <li><code>--desc</code> (str): Optional description for the output assets.</li> </ul> Auxiliary <code>run_cartload2</code> Paramaters <p>Auxiliary Conversion Parameters:</p> <ul> <li><code>--in-fic-params</code> (str): Path to input JSON file with SGE files and FICTURE parameters (Default: <code>ficture.params.json</code>).</li> <li><code>--out-fic-assets</code> (str): Path to output JSON file to write FICTURE assets (Default: <code>ficture_assets.json</code>).</li> <li><code>--out-catalog</code> (str): Path to output YAML file for assets (Default: catalog.yaml).</li> <li><code>--background-assets</code> (str list): List of background asset descriptors in <code>[id:file]</code> or <code>[id1:id2:file]</code> format.</li> <li><code>--rename-x</code> (str): Column renaming rule for X axis in <code>tippecanoe</code> (Default: x:lon).</li> <li><code>--rename-y</code> (str): Column renaming rule for Y axis in <code>tippecanoe</code> (Default: y:lat).</li> <li><code>--colname-feature</code> (str): Column name for gene/feature name (Default: gene).</li> <li><code>--colname-count</code> (str): Column name for feature count (Default: count).</li> <li><code>--out-molecules-id</code> (str): Prefix for output molecule PMTiles files (Default: genes).</li> <li><code>--max-join-dist-um</code> (float): Maximum join distance (\u00b5m) between molecules and pixels (Default: 0.1).</li> <li><code>--join-tile-size</code> (float): Tile size (\u00b5m) for molecule\u2013pixel joining. (Default: 500).</li> <li><code>--max-tile-bytes</code> (int): Maximum allowed tile size in bytes for PMTiles (Default: 5e6).</li> <li><code>--max-feature-counts</code> (int): Maximum number of features per tile (Default: 5e5).</li> <li><code>--preserve-point-density-thres</code> (int): Threshold to preserve point density in PMTiles (Default: 1024).</li> <li><code>--keep-intermediate-files</code> (flag): If set, retain intermediate files generated.</li> <li><code>--skip-raster</code> (flag): If set, skip raster tile generation and related dependencies.</li> <li><code>--tmp-dir</code> (str): Path to a temporary directory (Default: <code>&lt;out-dir&gt;/tmp</code>).</li> </ul> <p>Auxiliary Environment Parameters:</p> <ul> <li><code>--gzip</code> (str): Path to the <code>gzip</code> binary. For faster compression, use <code>\"pigz -p4\"</code> (Default: gzip).</li> <li><code>--pmtiles</code> (str): Path to the <code>pmtiles</code> binary from go-pmtiles (Default: pmtiles).</li> <li><code>--gdal_translate</code> (str): Path to the <code>gdal_translate</code> binary (Default: gdal_translate).</li> <li><code>--gdaladdo</code> (str): Path to the <code>gdaladdo</code> binary (Default: gdaladdo).</li> <li><code>--tippecanoe</code> (str): Path to the <code>tippecanoe</code> binary (Default: tippecanoe).</li> <li><code>--spatula</code> (str): Path to the <code>spatula</code> binary (Default: spatula).</li> </ul>"},{"location":"step_by_step/run_cartload2/#output","title":"Output","text":""},{"location":"step_by_step/run_cartload2/#copied-ficture-output","title":"Copied FICTURE Output","text":"<p>Copied FICTURE output from <code>&lt;fic_dir&gt;</code>. See formats in FICTURE analysis.</p>"},{"location":"step_by_step/run_cartload2/#rasterized-transcript-level-sge","title":"Rasterized transcript-level SGE","text":"<ul> <li>SGE mono PMTiles (<code>sge-mono-dark.pmtiles</code> and <code>sge-mono-light.pmtiles</code>): Rasterized gene expression tiles created from raw SGE for web visualization.</li> </ul>"},{"location":"step_by_step/run_cartload2/#rasterized-spatial-factor-maps","title":"Rasterized Spatial Factor Maps","text":"<ul> <li>Factor probability PMTiles (<code>*-results.pmtiles</code>): Vector tiles encoding posterior topic probabilities per spatial location.</li> <li>Decoded factor PMTiles (<code>*-pixel-raster.pmtiles</code>): Rasterized spatial factor maps derived from pixel-level decoding results.</li> </ul>"},{"location":"step_by_step/run_cartload2/#joined-molecule-factor-pmtiles","title":"Joined molecule-factor PMTiles","text":"<ul> <li>Joined molecule-factor TSV (<code>transcripts_pixel_joined.tsv.gz</code>): Merged file linking transcript-level SGE with decoded pixel factors.</li> <li>Final molecule PMTiles (*_pmtiles_index.tsv, <code>*_bin_counts.json</code>): Indexed, multi-feature PMTiles built from joined pixel-factor data for CartoScope.</li> </ul>"},{"location":"step_by_step/run_cartload2/#summary-files","title":"Summary Files","text":"<ul> <li>FICTURE assets file (ficture_assets.json): JSON catalog listing all output files and their roles for each trained model.</li> <li>Catalog file (catalog.yaml): Final YAML file summarizing all visual assets and layers for further deployment and visualization.</li> </ul>"},{"location":"step_by_step/run_ficture2/","title":"Spatial Factor Inference Analysis using FICTURE","text":""},{"location":"step_by_step/run_ficture2/#overview","title":"Overview","text":"<p>Following harmonization, cartloader provides <code>run_ficture2</code> module to run spatial factor inference using <code>FICTURE</code> (Si et al., Nature Methods, 2024). This method infers spatial factors directly at the pixel level with submicron resolution, eliminating the need for segmentation.</p> <p>What is <code>FICTURE</code>?</p> <p><code>FICTURE</code> reconstructs the fine-scale tissue structure by first decomposing gene expression patterns across the tissue section into spatial factors and then assigns each pixel to these factors using local context. Biologically, these inferred factors may correspond to specific cell types, functional or physiological states, subcellular domains, or extracellular transcriptomic signatures.</p> <p>By default, <code>FICTURE</code> learns the spatial factors by implementing a standard latent Dirichlet allocation (LDA) model on a hexagonal grid overlay of the spatial coordinates. Optionally, spatial factors can also be derived from external sources, such as single-cell or single-nucleus RNA-seq reference datasets, or from spatially agnostic factor learning methods (e.g., Seurat, Scanpy).</p> <p>The <code>punkst</code> version of <code>FICTURE</code></p> <p>To efficiently run FICTURE-based inference, cartloader integrates <code>punkst</code>, an optimized implementation of FICTURE that maintains output equivalence while enhancing computational scalability and performance. </p> <p>Currently, <code>run_ficture2</code> is using <code>punkst</code> version of <code>FICTURE</code>.</p>"},{"location":"step_by_step/run_ficture2/#requirements","title":"Requirements","text":"<ul> <li>An SGE in the unified format (from SGE harmonization) </li> <li>Pre-installed tools: <code>spatula</code>, <code>punkst</code>, <code>gzip</code>, <code>sort</code>, <code>python</code></li> </ul>"},{"location":"step_by_step/run_ficture2/#example-usage","title":"Example Usage","text":"<pre><code>cartloader run_ficture2 \\\n    --main \\\n    --in-transcript /path/to/input/harmonized/transcripts/tsv/file \\\n    --in-feature /path/to/input/harmonized/feature/tsv/file \\               # optional\n    --in-minmax /path/to/input/harmonized/coordinates/minmax/tsv/file \\     # optional\n    --cmap-file /path/to/cartloader/assets/fixed_color_map_256.tsv \\        # optional\n    --colname-count count \\\n    --out-dir /path/to/output/directory \\\n    --width 18 \\\n    --n-factor 24 \\\n    --spatula /path/to/spatula/binary \\\n    --ficture2 /path/to/punkst/directory \\  \n    --exclude-feature-regex '^(mt-|Gm\\d+$)' \\                               # optional\n    --n-jobs 20  \\\n    --threads 20 \n</code></pre>"},{"location":"step_by_step/run_ficture2/#actions","title":"Actions","text":""},{"location":"step_by_step/run_ficture2/#tiling-step","title":"Tiling step","text":"<p>The tiling step takes the standarized SGE (from SGE harmonization step) as input. It aims to reorganizes input coordinate data into non-overlapping square tiles in a plain TSV format and generates an index file with tile offsets to enable efficient random access.</p>"},{"location":"step_by_step/run_ficture2/#segmentation-step","title":"Segmentation Step","text":"<p>The segmentation step starts from the tiled SGE, using the plain TSV file from tiling step as input. It aggregates tiled pixel data into non-overlapping hexagons in a TSV file for spot-level analysis, outputting a tab-delimited file of hexagon records and associated metadata in JSON format.</p>"},{"location":"step_by_step/run_ficture2/#lda-training-step","title":"LDA Training Step","text":"<p>The LDA training step uses the hexagon TSV and JSON file from segmentation step as input, trains a Latent Dirichlet Allocation (LDA) model on sparse gene count data from hexagon units, using metadata to interpret input structure and optionally filter or weight features, producing a factorized topic model in TSV.</p>"},{"location":"step_by_step/run_ficture2/#decoding-step","title":"Decoding Step","text":"<p>The decoding step applies a trained LDA model from LDA training step to tiled pixel-level transcript data from tiling step to infer the top spatial factors and their posterior probabilities for each pixel, enabling fine-grained spatial mapping of gene expression. It outputs a pixel-level annotation file in TSV format with coordinates and factor assignments, along with a pseudobulk gene-by-factor matrix in TSV format.</p>"},{"location":"step_by_step/run_ficture2/#summarization-step","title":"Summarization Step","text":"<p>The summarization step generate a JSON file to include all details of the FICTURE analysis, including the input files, output files, and parameters.</p>"},{"location":"step_by_step/run_ficture2/#parameters","title":"Parameters","text":"<p>The following outlines the minimum required parameters for running FICTURE2. </p> <p>For auxiliary parameters, we recommend using the default values unless you possess a thorough understanding of FICTURE. For further details, refer to the collapsible sections below or run:</p> <pre><code>cartloader run_ficture2 --help\n</code></pre>"},{"location":"step_by_step/run_ficture2/#action-parameters","title":"Action Parameters","text":"<p>Action Specifications</p> <p>At least one of the actions (<code>--main</code>, <code>--tile</code>, <code>--segment</code>, <code>--init-lda</code>, <code>--decode</code>, <code>--summary</code>) should be enabled.</p> <ul> <li><code>--main</code>: Run all of the following five actions.</li> <li><code>--tile</code>: Run tiling step.</li> <li><code>--segment</code>: Run segmentation step.</li> <li><code>--init-lda</code>: Run LDA training step.</li> <li><code>--decode</code>: Run decoding step.</li> <li><code>--summary</code>: Run summarization step.</li> </ul>"},{"location":"step_by_step/run_ficture2/#inputoutput-parameters","title":"Input/Output Parameters","text":"<ul> <li><code>--out-dir</code> (str): Output directory to store all result files.</li> <li><code>--out-json</code> (str): Output JSON file summarizing FICTURE parameters (Default: <code>&lt;out-dir&gt;/ficture.params.json</code>).</li> <li><code>--in-transcript</code> (str): Input transcript-indexed SGE file in TSV format.</li> <li><code>--in-minmax</code> (str): Optional input coordinate min-max file.</li> <li><code>--in-feature</code> (str): Optional input UMI count per gene TSV file.</li> </ul>"},{"location":"step_by_step/run_ficture2/#key-parameters","title":"Key Parameters","text":"<ul> <li><code>--width</code> (str): Comma-separated hexagon flat-to-flat widths (in \u00b5m) for LDA training.</li> <li><code>--n-factor</code> (str): Comma-separated list of factor counts for LDA training.</li> <li><code>--include-feature-regex</code> (str): Regex pattern for including features/genes.</li> <li><code>--exclude-feature-regex</code> (str): Regex pattern for excluding features/genes.</li> <li><code>--cmap-file</code> (str): Optional path to fixed color map TSV file. If not provided, FICTURE will generate a color map.</li> </ul> Auxiliary <code>run_ficture2</code> Paramaters <p>Auxiliary Input Parameters</p> <ul> <li><code>--in-feature-ficture</code> (str): (Optional) A separate feature file applied to FICTURE analysis. Alternative to customizing via auxiliary parameters.</li> <li><code>--colidx-x</code> (int): Column index of X in the transcript file (Default: 1).</li> <li><code>--colidx-y</code> (int): Column index of Y in the transcript file (Default: 2).</li> <li><code>--colname-count</code> (str): Column name to use as count value (Default: count).</li> <li><code>--colname-feature</code> (str): Column name for gene/feature name (Default: gene).</li> </ul> <p>Auxiliary FICTURE Parameters:</p> <ul> <li>Tiling-specific parameters:<ul> <li><code>--tile-size</code> (int): Size of tiles for processing (Default: 500).</li> <li><code>--tile-buffer</code> (int): Buffer zone around each tile (Default: 1000).</li> </ul> </li> <li>Segmentation-specific parameters:<ul> <li><code>--min-ct-per-unit-hexagon</code> (int): Minimum count per hexagon (Default: 50).</li> <li><code>--minibatch-size</code> (int): Minibatch size for preprocessing (Default: 500).</li> </ul> </li> <li>LDA training-specific parameters:<ul> <li><code>--min-ct-per-unit-train</code> (int): Minimum count for training (Default: 50).</li> <li><code>--train-epoch</code> (int): Number of epochs to train LDA model (Default: 2).</li> </ul> </li> <li>Decoding-specific paramaters:<ul> <li><code>--fit-width</code> (int): Hexagon width (in \u00b5m) for model fitting (Default: same as train width).</li> <li><code>--min-ct-per-unit-fit</code> (int): Minimum count per unit during model fitting (Default: 50).</li> <li><code>--anchor-res</code> (int): Anchor resolution used in decoding (Default: 6).</li> <li><code>--radius-buffer</code> (int): Buffer added to anchor resolution for decoding (Default: 1).</li> <li><code>--fit-plot-um-per-pixel</code> (int): Image resolution for fit coarse plots (Default: 1).</li> </ul> </li> <li>Shared paramaters across steps:<ul> <li><code>--seed</code> (int): Random seed for reproducibility (Default: 1).</li> <li><code>--min-ct-per-feature</code> (int): Minimum count per feature for LDA and decoding (Default: 20).</li> <li><code>--de-max-pval</code> (float): p-value cutoff for differential expression (Default: 1e-3).</li> <li><code>--de-min-fold</code> (float): Fold-change threshold for differential expression (Default: 1.5).</li> </ul> </li> </ul> <p>Auxiliary Environment Parameters: For tools that require specifying the path to their executable binaries, you may omit the path if the binary is already included in your system's <code>PATH</code>.</p> <ul> <li><code>--gzip</code> (str): Path to <code>gzip</code> binary; consider <code>pigz -p 4</code> for speed (Default: <code>gzip</code>).</li> <li><code>--sort</code> (str): Path to <code>sort</code> binary (Default: <code>sort</code>).</li> <li><code>--sort-mem</code> (str): Memory allocated per <code>sort</code> process (Default: 1G).</li> <li><code>--spatula</code> (str): Path to <code>spatula</code> binary (Default: <code>spatula</code>).</li> <li><code>--ficture2</code> (str): Path to the <code>punkst</code> repository (Default to <code>punkst</code> directory in <code>submodules</code>)</li> <li><code>--python</code> (str): Path to Python 3 binary (Default: <code>python3</code>).</li> </ul>"},{"location":"step_by_step/run_ficture2/#output","title":"Output","text":""},{"location":"step_by_step/run_ficture2/#tiling-output","title":"Tiling Output","text":"<ul> <li><code>transcripts.tiled.tsv</code>: A tab-delimited TSV file where each line records a tile with X and Y coordinates, a feature name (e.g., gene), and its associated count.     <pre><code>3815.69 491.9   Arfgef1 1\n</code></pre></li> <li><code>transcripts.tiled.index</code>: An index file that records the byte offsets of each tile in the tiled TSV file, enabling fast random access to tile-specific data. It includes comment lines with metadata (tile size, pixel count, min/max X and Y coordinates) and data lines listing the offset positions for each tile.     <pre><code># tilesize  500\n# npixels   333021294\n# xmin  0.28\n# xmax  19851.1\n# ymin  0.5\n# ymax  13476.4\n0   7   0           13103550    569474\n0   8   13103550    40259340    1180529\n</code></pre></li> <li><code>transcripts.tiled.coord_range.tsv</code>: A tab-delimited TSV file provides xmin, xmax, ymin, and ymax as key\u2013value pairs.     <pre><code>xmin    0.28\nxmax    19851.1\nymin    0.5\nymax    13476.4\n</code></pre></li> <li><code>transcripts.tiled.features.tsv</code>: A tab-delimited TSV file listing each feature name and its expression count per line.     <pre><code>1810009J06Rik   1\nGm48545         1\n</code></pre></li> </ul>"},{"location":"step_by_step/run_ficture2/#segmentation-output","title":"Segmentation Output","text":"<ul> <li> <p><code>hexagon_d_{width}.randomized.tsv</code>: A plain-text TSV file that stores sparse feature representations for hexagon units, with each line corresponding to one hexagon.</p> <p>File Format</p> <p>This is not a regular table\u2014the number of columns varies across lines depending on the number of features present in each hexagon.</p> <pre><code>00001c64  18999.0000  9773.9627  227  244   2417 1  10469 2  2448 1  543 1   10935 1  6460 1  1797 1  6517 1  1094 1  9872 1  8587 1  7137 1  8786 1  10564 1  2127 1  439 1   1529 1  8432 1   1304 1  1739 1   3012 1  6434 1  5297 1  10017 1  2567 1  4771 1  5644 1  6415 1  5258 1   258 1   2314 1  6378 1  8843 1  7386 1  3322 1  2041 1  4735 1  9755 1  8614 1   4665 1  5693 1  2194 1  1680 1  10406 1  2696 1  7250 1  2367 1  7189 1  1616 1  10721 1  441 1   9981 1   8696 1  1012 1  8545 1  835 1   6550 1  4409 1  1860 1  575 1   139 1   5473 1  10172 1  7316 1  5260 1  180 1   2068 1  10806 1  8817 1  1621 1  4542 1  6193 1  440 1   6608 1  6989 1  4782 1  3258 1  5205 1  1093 1  9060 1  1921 1  6333 1   846 1   10575 1  2608 1  10186 1  932 1   2217 1  5392 1  2275 1  4845 1   8401 1  341 1   2810 1   754 1   4501 1  1160 1  5354 1  5097 1  3713 1  1619 1  9843 1  2749 1  1207 1  7384 1  2758 1  445 1   9040 1  45 1    2517 1   11255 1  8161 1  393 1   2963 1  3457 1  4481 1  10649 1  6954 2  2842 1  7982 1  2034 1  2849 2  5393 1  5257 1  773 1   1030 1  5455 1  2380 1  7079 1  1491 1  353 1    5343 1  1231 1  178 1   8659 1  10994 1  6168 1  267 1    6770 1   9083 1   2691 1  2423 2  3058 3  6921 1  1778 1  236 1   7175 1  7683 1   47 1    9094 2  1898 1  6524 1  5640 1  6668 1   6411 1  3536 1  10475 2  6538 1  1443 1  2728 1  7717 1  4633 1  6634 1   5349 1  11215 2  9159 1  2129 1  5984 1  8584 2  7042 1  3819 2  7931 1  2343 1  1182 2  2724 1  1871 1  716 1   1744 1  263 1   7459 1  6737 1  4654 1   9023 1  775 2    1546 1  1512 1  6395 1  5624 1  1560 2  8919 2  4689 1  2403 1  4163 1  5705 1  1260 1  8068 1  1900 1  1701 1  1187 1  8172 1  5955 1  494 1   428 1   6082 1  479 1   5362 1   11273 1  1764 1   9546 1  8261 1  11088 1  6262 1  2154 1  612 1   6777 2  866 1    10850 1  4168 1  9334 1  9077 2   3818 1  732 1   6386 1  989 1   1277 1  319 1   6230 1\n</code></pre> <ul> <li>1st column (str): Random identifier for the hexagon</li> <li>2nd and 3rd columns (float): Axial coordinates in the hexagonal coordinate system</li> <li>4th and 5th columns (int): Number of unique features and total counts, repeated per modality (for K modalities)</li> <li>6th column onward (integer integer): Index\u2013count pairs for non-zero features, using 0-based indices from --feature-dict or as provided in the input file</li> </ul> </li> <li> <p><code>hexagon_d_{width}.json</code>: The meta data for the hexagons. such as, , hexagon size, x and y column indices (), number of features, number of modalities, and number of hexagons (<code>n_units</code>),     <pre><code>{\n\"dictionary\": {\n    \"A2m\": 9636,\n    \"AA986860\": 6486,\n    ...\n    },\n    \"header_info\": [\n        \"random_key\",\n        \"x\",\n        \"y\"\n    ],\n    \"hex_size\": 10.392304845413264,\n    \"icol_x\": 1,\n    \"icol_y\": 2,\n    \"n_features\": 11319,\n    \"n_modalities\": 1,\n    \"n_units\": 498019,\n    \"offset_data\": 3,\n    \"random_key\": 0\n}\n</code></pre></p> <ul> <li><code>dictionary</code>: The feature name-idex pairs</li> <li><code>header_info</code>: Header information</li> <li><code>hex_size</code>: Size of hexagons</li> <li><code>icol_x</code> and <code>icol_y</code>: Indices of X and Y coordinates</li> <li><code>n_features</code>: Number of features</li> <li><code>n_modalities</code>: Number of modalities</li> <li><code>n_units</code>: Number of hexagons</li> <li><code>offset_data</code>: ?</li> <li><code>random_key</code>: the random seed for reproduction</li> </ul> </li> </ul>"},{"location":"step_by_step/run_ficture2/#lda-training-output","title":"LDA Training Output","text":"<ul> <li><code>t{width}_f{n_factor}.model.tsv</code>: A matrix to store the learned topic-word distribution.     <pre><code>Feature  0        1      2      3      4      5      6         7      8      9      10        11       12     13     14        15     16     17     18      19     20      21     22     23\nNeu4     481.168  0.042  0.042  0.042  0.042  0.042  1828.293  0.042  0.042  0.042  2290.443  836.722  0.042  0.042  1704.589  0.042  0.042  0.042  29.738  0.042  24.854  0.042  0.042  0.042\n</code></pre><ul> <li>Rows (str): LDA topics or spatial factors</li> <li>Columns (int): Feature identifiers (e.g., gene names or indices)</li> <li>Values (float): Probability or weight of a feature under each topic <code>(P(feature | topic))</code></li> </ul> </li> <li><code>t{width}_f{n_factor}.results.tsv.gz</code>: A tab-delimited file containing the posterior topic distributions for each hexagon. <pre><code>x           y          0       1       2       3       4       5       6       7       8       9       10      11      12      13      14      15      16      17      18      19      20      21      22      23      topK  topP\n14202.0000  5393.6062  0.0000  0.5087  0.0860  0.0000  0.0269  0.0000  0.0136  0.0000  0.0000  0.0179  0.0153  0.0000  0.0490  0.0000  0.0982  0.0000  0.0911  0.0199  0.0143  0.0189  0.0373  0.0000  0.0030  0.0000  1     0.5087\n</code></pre><ul> <li><code>x</code> and <code>y</code> (float): X Y coordinates of the hexagon.</li> <li>Columns <code>0</code> to <code>{n_factor-1}</code> (float): Posterior probabilities for each latent factor <code>(P(topic | hexagon))</code></li> <li><code>topK</code> (int): Index of the most probable factor</li> <li><code>topP</code> (float): Posterior probability of the top factor</li> </ul> </li> <li> <p><code>t{width}_f{n_factor}.bulk_chisq.tsv</code> <pre><code>gene  factor  Chi2      pval      FoldChange  gene_total  log10pval\nApp   0       864182.5  0.00e+00  4.41        1422353     187657.91\n</code></pre></p> <ul> <li><code>gene</code> (str): Gene names.</li> <li><code>factor</code> (int): Factor IDs.</li> <li><code>Chi2</code> (float): Chi-squared test statistic comparing the expression in the target factor and the rest.</li> <li><code>pval</code> (float): P-value associated with the chi-squared test.</li> <li><code>FoldChange</code> (float): Ratio of gene expression inside versus outside the factor\u2019s high-loading region.</li> <li><code>gene_total</code> (int): Total count of the gene in the dataset.</li> <li><code>log10pval</code> (float): Base-10 logarithm of the inverse p-value (i.e., -log10(pval)), useful for ranking significant genes.</li> </ul> </li> <li> <p><code>t{width}_f{n_factor}.factor.info.tsv</code> and <code>t{width}_f{n_factor}.factor.info.html</code>: A TSV and HTML file providing the information for each factor per line.     <pre><code>Factor  RGB          Weight   PostUMI   TopGene_pval                                                                                                                                       TopGene_fc                                                                                                                                           TopGene_weight\n0       255,101,101  0.11279  82949360  App, Snrpn, Calm3, Eef1a2, Dctn1, Ptprn2, Akt3, Tmem181a, Sgtb, Ncdn, Selenow, Atp6v0a1, Cacng8, Atp2a2, Stub1, Akap5, Cmip, Cap1, Rundc3a, Ptprn  Sgtb, Map3k9, Cmip, Vps51, Ptprn2, Zscan2, Ppp2cb, Cacng8, Als2, Eif4e3, Ubxn2a, Gabrb2, Pms1, Rnpc3, Prepl, Zfp418, Tmem181a, Akap5, Dctn1, Atp2b3  App, Calm3, Selenow, Camk2n1, Snrpn, Ncdn, Atp2a2, Eef1a2, Uchl1, Ndfip1, Snap25, Stxbp1, Ywhag, Arf3, Serinc1, Atp6v1b2, Maged1, Atp6v0a1, Dnm1, Rab6b\n</code></pre></p> <ul> <li><code>Factor</code> (int): Factor IDs</li> <li><code>RGB</code> (str): Comma-separated RGB values</li> <li><code>Weight</code> (float): Proportion of the total factor signal explained by this factor</li> <li><code>PostUMI</code> (int): Sum of posterior UMI counts across all spatial locations for this factor</li> <li><code>TopGene_pval</code>, <code>TopGene_fc</code>, <code>TopGene_weight</code> (str): Top marker genes per factor ranked by significance (p-value), fold change, or weight</li> </ul> </li> <li><code>t{width}_f{n_factor}.cmap.tsv</code>: a color map.     <pre><code>R    G    B    Color_hex  Name\n255  101  101  #ff6565    0\n</code></pre><ul> <li><code>Name</code> (int): Factor IDs</li> <li><code>Color_hex</code> (str): Color HEX code</li> <li><code>R</code>, <code>G</code>, <code>B</code> (float): Red, Green, and Blue channel values (range: 0.0 to 1.0)</li> </ul> </li> </ul>"},{"location":"step_by_step/run_ficture2/#decoding-output","title":"Decoding Output","text":"<ul> <li> <p><code>t{width}_f{n_factor}_p{width}_a{anchor_res}.tsv.gz</code>: A tab-delimited file where each line represents a pixel\u2013feature pair, recording the pixel\u2019s coordinates, the expressed feature and its count, along with the top three most probable latent factors (<code>K1</code>\u2013<code>K3</code>) and their corresponding probabilities (<code>P1</code>\u2013<code>P3</code>).     <pre><code>#x         y         feature  ct  K1  K2  K3  P1          P2          P3\n5159.4800  450.1500  Retreg2  1   0   19  9   9.5073e-01  4.8011e-02  5.0298e-04\n</code></pre></p> <ul> <li><code>x</code> and <code>y</code> (float): X Y coordinates</li> <li><code>feature</code> (str): feature names.</li> <li><code>ct</code> (int): count</li> <li><code>K1</code> (int) and <code>P1</code> (float): The most probable factor and its probability</li> <li><code>K2</code> (int) and <code>P2</code> (float): The 2nd most probable factor and its probability</li> <li><code>K3</code> (int) and <code>P3</code> (float): The 3rd most probable factor and its probability</li> </ul> </li> <li> <p><code>t{width}_f{n_factor}_p{width}_a{anchor_res}.index</code>: An index file for <code>t{width}_f{n_factor}_p{width}_a{anchor_res}.tsv.gz</code>.</p> </li> <li><code>t{width}_f{n_factor}_p{width}_a{anchor_res}.json</code>: A JSON file to provide header information for <code>t{width}_f{n_factor}_p{width}_a{anchor_res}.tsv.gz</code>.     <pre><code>{\n    \"K1\": 4,\n    \"K2\": 5,\n    \"K3\": 6,\n    \"P1\": 7,\n    \"P2\": 8,\n    \"P3\": 9,\n    \"ct\": 3,\n    \"feature\": 2,\n    \"x\": 0,\n    \"y\": 1\n}\n</code></pre></li> <li><code>t{width}_f{n_factor}_p{width}_a{anchor_res}.png</code>: A PNG file to visualize the spatial factors distribution at pixel level.</li> <li> <p><code>t{width}_f{n_factor}_p{width}_a{anchor_res}.pseudobulk.tsv</code>: A feature-by-factor matrix showing feature distribution across topics.     <pre><code>Feature  0         1       2       3       4       5       6          7       8       9       10         11        12      13      14        15      16      17      18       19      20       21      22      23\nNeu4     648.5156  0.0000  0.9999  0.0000  0.0000  2.1425  1316.2651  0.0000  0.0000  0.0000  1114.2935  527.5519  0.0000  0.0000  820.3735  0.0000  0.0000  3.3504  30.4680  0.0000  38.0400  0.0000  0.0000  0.0000\n</code></pre></p> <ul> <li>Rows (str): LDA topics or spatial factors</li> <li>Columns (int): Feature identifiers (e.g., gene names or indices)</li> <li>Values (float): Posterior probability of a feature in a factor.</li> </ul> </li> <li> <p><code>t{width}_f{n_factor}_p{width}_a{anchor_res}.bulk_chisq.tsv</code>: Same format as the <code>t{width}_f{n_factor}.bulk_chisq.tsv</code></p> </li> <li><code>t{width}_f{n_factor}_p{width}_a{anchor_res}.factor.info.tsv</code>:  Same format as the <code>t{width}_f{n_factor}.factor.info.tsv</code></li> <li><code>t{width}_f{n_factor}_p{width}_a{anchor_res}.factor.info.html</code>: Same format as the <code>t{width}_f{n_factor}.factor.info.html</code></li> </ul>"},{"location":"step_by_step/run_ficture2/#summarization-output","title":"Summarization Output","text":"<ul> <li><code>ficture.params.json</code>: A JSON file to summarize the path to input, output, and paramaters.     <pre><code>{\n\"in_sge\": {\n    \"in_transcript\": \"/path/to/transcripts.unsorted.tsv.gz\",\n    \"in_feature\": \"/path/to/transcripts.tiled.features.hdr.tsv\",\n    \"in_minmax\": \"/path/to/coordinate_minmax.tsv\"\n},\n\"in_feature_ficture\": \"/path/to/transcripts.tiled.overlapping_features.min100.hdr.tsv\", # if available\n\"train_params\": [\n    {\n        \"model_type\": \"lda\",\n        \"model_id\": \"t{width}_f{n_factor}\",\n        \"model_path\": \"/path/to/t{width}_f{n_factor}.model.tsv\",\n        \"train_width\": width,\n        \"n_factor\": n_factor,\n        \"cmap\": \"/path/to/t{width}_f{n_factor}.cmap.tsv\",\n        \"decode_params\": [\n            {\n                \"decode_id\": \"t{width}_f{n_factor}_p{width}_a{anchor_res}\",\n                \"fit_width\": width,\n                \"anchor_res\": anchor_res\n            }\n        ]\n    }\n]\n}\n</code></pre></li> </ul>"},{"location":"step_by_step/sge_harmonization/","title":"Spatial Gene Expression (SGE) Harmonization","text":""},{"location":"step_by_step/sge_harmonization/#overview","title":"Overview","text":"<p>Spatial Digital Gene Expression (SGE) datasets vary widely in format and resolution across platforms. To enable consistent downstream analysis, <code>cartloader</code> toolkit provides a <code>sge_convert</code> module to harmonize raw SGE data by converting it into standardized transcript-based SGE in a compressed TSV format, with spatial coordinates converted to a micrometer-based unit system without altering the original resolution.</p> <p>The current <code>sge_convert</code> supports standarizing SGE from sequencing-based platforms (e.g., Seq-Scope, Stereo-seq, Pixel-seq, 10x Visium HD) and imaging-based platforms (e.g., 10x Xenium, Vizgen MERSCOPE, CosMx SMI).</p>"},{"location":"step_by_step/sge_harmonization/#example-usages","title":"Example Usages","text":""},{"location":"step_by_step/sge_harmonization/#input-sge-in-mex-format","title":"Input SGE in MEX Format","text":""},{"location":"step_by_step/sge_harmonization/#seq-scope","title":"<code>Seq-Scope</code>","text":"<pre><code>cartloader sge_convert \\\n    --platform seqscope \\\n    --in-mex /path/to/input/dir/of/mex \\   \n    --units-per-um 1000 \\\n    --icols-mtx 1 \\\n    --out-dir /path/to/output/dir \\\n    --colnames-count count \\\n    --filter-by-density \\\n    --out-filtered-prefix filtered \\\n    --genomic-feature count \\\n    --sge-visual \\\n    --north-up \\\n    --spatula /path/to/spatul/binary \n</code></pre>"},{"location":"step_by_step/sge_harmonization/#10x-visium-hd","title":"<code>10X Visium HD</code>","text":"<pre><code>cartloader sge_convert \\\n    --platform 10x_visium_hd \\\n    --in-mex /path/to/input/dir/of/mex \\   \n    --icols-mtx 1 \\\n    --in-parquet /path/to/input/parquet/file \\\n    --scale-json /path/to/input/json/file \\\n    --exclude-feature-regex '^(BLANK.*$|NegCon.*$|NegPrb.*$|mt-.*$|Gm\\d+$)' \\\n    --out-dir /path/to/output/dir \\\n    --spatula /path/to/spatul/binary \\\n    --sge-visual \n</code></pre>"},{"location":"step_by_step/sge_harmonization/#input-sge-in-tsvcsv-format","title":"Input SGE in TSV/CSV Format","text":"<p>This applied to input SGE in TSV/CSV format from platforms including 10X Xenium, StereoSeq, Cosmx SMI, MERSCOPE, Pixel-seq. Below is an example converting SGE from StereoSeq.</p> <pre><code>cartloader sge_convert \\\n    --platform bgi_stereoseq \\\n    --in-csv /path/to/input/csv/file \\\n    --units-per-um 28.75 \\\n    --out-dir /path/to/output/dir \\\n    --colnames-count count \\\n    --exclude-feature-regex '^(BLANK.*$|NegCon.*$|NegPrb.*$|mt-.*$|Gm\\d+$)' \\\n    --filter-by-density \\\n    --out-filtered-prefix filtered \\\n    --genomic-feature count \\\n    --sge-visual \\\n    --north-up \\\n    --spatula /path/to/spatul/binary \n</code></pre>"},{"location":"step_by_step/sge_harmonization/#actions","title":"Actions","text":"<p>The following outlines the minimum required parameters for running SGE harmonization. </p> <p>For most auxiliary parameters, the default values are recommended and should only be modified when they do not suit your use case, e.g., the auxiliary input parameters. See more details in the collapsible sections below or by running: <pre><code>cartloader sge_convert --help\n</code></pre></p>"},{"location":"step_by_step/sge_harmonization/#sge-conversion","title":"SGE Conversion","text":"<ul> <li> <p><code>--platform</code>: Source platform to infer the input file format and default setting. </p> <code>platform</code> options <ul> <li><code>10x_visium_hd</code>: 10X Visium HD. Provide raw SGE by <code>--in-mex</code>, <code>--in-parquet</code>, <code>--scale-json</code>.</li> <li><code>seqscope</code>: SeqScope. Provide raw SGE by <code>--in-mex</code>.</li> <li><code>10x_xenium</code>: 10X Xenium. Provide raw SGE by <code>--in-csv</code>.</li> <li><code>bgi_stereoseq</code>: StereoSeq. Provide raw SGE by <code>--in-csv</code>.</li> <li><code>cosmx_smi</code>: CosMX SMI. Provide raw SGE by <code>--in-csv</code>.</li> <li><code>vizgen_merscope</code>: Vizgen MERSCOPE. Provide raw SGE by <code>--in-csv</code>.</li> <li><code>pixel_seq</code>: Pixel-seq. Provide raw SGE by <code>--in-csv</code>.</li> <li><code>nova_st</code>: NovaST. Provide raw SGE by <code>--in-csv</code>.</li> <li><code>generic</code>: Generic TSV input. Provide raw SGE by <code>--in-csv</code>.</li> </ul> </li> <li> <p><code>--in-mex</code>: Path to the input SGE directory in MEX format. Required for MEX-formatted data (e.g., 10X Visium HD, SeqScope).</p> </li> <li><code>--in-csv</code>: Path to the input SGE file in CSV or TSV format. Required for CSV/TSV-formatted data (e.g., 10X Xenium, StereoSeq, CosMX SMI, MERSCOPE, Pixel-seq, NovaST).</li> <li><code>--in-parquet</code>: Path to the input parquet file with spatial coordinates, if available. Typically named <code>tissue_positions.parquet</code> (10X Visium HD).</li> <li><code>--scale-json</code>: Path to the scale JSON file used to compute <code>--units-per-um</code>, if available. Typically named <code>scalefactors_json.json</code> (10X Visium HD).</li> <li><code>--units-per-um</code>: Coordinate units per micrometer (default: 1.00). Skip if <code>--scale-json</code> is provided.</li> <li><code>--out-dir</code>: Path to the output directory.</li> </ul> Auxiliary SGE Conversion Paramaters <p>Auxiliary Input MEX Parameters:</p> <ul> <li><code>--icols-mtx</code>: Comma-separated, 1-based indices of the target genomic features among the count columns in the input matrix file. (Default: 1)</li> <li><code>--colnames-count</code>: Comma-separated output column names for the specified genomic features. (Default: count). The number of names specified by <code>--colnames-count</code> must match the number of indices provided in <code>--icols-mtx</code>.</li> </ul> <p>Auxiliary Input CSV/TSV Parameters:</p> <ul> <li><code>--csv-comment</code>: If enabled, lines starts with <code>#</code> will be skipped (default: <code>False</code> for 10X Xenium, StereoSeq, CosMx SMI, MERSCOPE, and Pixel-seq; <code>True</code> for NovaST).</li> <li><code>--csv-delim</code>: Delimiter for the input file (default: <code>\",\"</code> for 10X Xenium, CosMx SMI, and MERSCOPE; <code>\"\\t\"</code> for StereoSeq, Pixel-seq, and NovaST).</li> <li><code>--csv-colname-x</code>: Column name for X coordinates (default: <code>x_location</code> for 10X Xenium; <code>x</code> for StereoSeq and NovaST; <code>x_local_px</code> for CosMx SMI; <code>global_x</code> for MERSCOPE; <code>xcoord</code> for Pixel-seq).</li> <li><code>--csv-colname-y</code>: Column name for Y coordinates (default: <code>y_location</code> for 10X Xenium; <code>y</code> for StereoSeq and NovaST; <code>y_local_px</code> for CosMx SMI; <code>global_y</code> for MERSCOPE; <code>ycoord</code> for Pixel-seq).</li> <li><code>--csv-colnames-count</code>: Comma-separated column names for expression count. If not provided, a count of 1 per transcript (default: <code>MIDCounts</code> for StereoSeq; <code>MIDCount</code> for NovaST).</li> <li><code>--csv-colname-feature-name</code>: Column name for gene name (default: <code>feature_name</code> for 10X Xenium; <code>geneID</code> for StereoSeq; <code>target</code> for CosMx SMI; <code>gene</code> for MERSCOPE; <code>geneName</code> for Pixel-seq; <code>geneID</code> for NovaST). </li> <li><code>--csv-colnames-others</code>: Columns names to keep.</li> <li><code>--csv-colname-phredscore</code>: Column name for Phred-scaled quality value estimating the probability of incorrect calls (default: <code>qv</code> for 10X Xenium).</li> <li><code>--min-phred-score</code>: Phred-scaled quality score cutoff (default: <code>20</code> for 10X Xenium).</li> </ul> <p>Auxiliary Output Parameters: </p> <ul> <li><code>--out-transcript</code>: File name for output compressed transcript-indexed SGE file in TSV format (default: <code>transcripts.unsorted.tsv.gz</code>).</li> <li><code>--out-minmax</code>: File name for coordinate min-max values in TSV format (default: <code>coordinate_minmax.tsv</code>).</li> <li><code>--out-feature</code>: File name for compressed UMI count per gene in TSV format (default: <code>feature.clean.tsv.gz</code>).</li> <li><code>--precision-um</code>: Decimal precision for transcript coordinates; set to <code>0</code> to round to integers (default: 2).</li> <li><code>--colname-x</code>: Column name for the X-coordinate in the output SGE (default: X).</li> <li><code>--colname-y</code>: Column name for the Y-coordinate in the output SGE (default: Y).</li> <li><code>--colnames-count</code>: Comma-separated column names for expression count in the output SGE (default: count).</li> <li><code>--colname-feature-name</code>: Column name for the gene name in the output SGE(default: gene). </li> </ul> <p>Auxiliary Environment Parameters If the binaries are already available in your system's <code>PATH</code>, you may omit these options.</p> <ul> <li><code>--gzip</code> (str): Path to <code>gzip</code> binary; consider <code>pigz -p 4</code> for faster processing. (Default: <code>gzip</code>)</li> <li><code>--spatula</code> (str): Path to <code>spatula</code> binary. (Default: <code>spatula</code>)</li> <li><code>--parquet-tools</code> (str): Required if <code>--in-parquet</code> is used; path to <code>parquet-tools</code> binary. (Default: <code>parquet-tools</code>)</li> </ul>"},{"location":"step_by_step/sge_harmonization/#optional-gene-filtering","title":"Optional Gene Filtering","text":"<ul> <li><code>--include-feature-regex</code>: A regex pattern of feature/gene names to be included.</li> <li><code>--exclude-feature-regex</code>: A regex pattern of feature/gene names to be excluded.</li> </ul>"},{"location":"step_by_step/sge_harmonization/#optional-density-based-filtering","title":"Optional Density-based Filtering","text":"<ul> <li><code>--filter-by-density</code>: Enable filtering of SGE by density.</li> <li><code>--out-filtered-prefix</code>: Prefix for output filtered SGE files (default: filtered).</li> <li><code>--genomic-feature</code>: Genomic feature to be used for density-based filtering. Defaults to the value of <code>--colnames-count</code> if only one column name is provided.</li> </ul> Auxiliary Density-based Filtering Paramaters <ul> <li><code>--mu-scale</code>: Scale factor for the polygon area calculation (default: 1.0).</li> <li><code>--radius</code>: Radius for the polygon area calculation (default: 15).</li> <li><code>--quartile</code>: Quartile for the polygon area calculation (default: 2).</li> <li><code>--hex-n-move</code>: Sliding step (default: 1).</li> <li><code>--polygon-min-size</code>: The minimum polygon size (default: 500).</li> </ul>"},{"location":"step_by_step/sge_harmonization/#optional-sge-visualization","title":"Optional SGE Visualization","text":"<ul> <li><code>sge-visual</code>: Enable SGE visualization.</li> <li><code>--north-up</code>: Enable the north-up orientation for the SGE visualization.</li> </ul> Auxiliary SGE Visualization Paramaters <ul> <li><code>--out-xy</code> (str): File name for output SGE visualization image (default: <code>xy.png</code>).</li> <li><code>--out-northup-tif</code> (str): File name for output north-up orientated image (default: <code>xy_northup.tif</code>).</li> <li><code>--srs</code> (str): If <code>--north-up</code>, define the spatial reference system (default: EPSG:3857).</li> <li><code>--resample</code> (str): If <code>--north-up</code>, Define the resampling method (default: cubic). Options: near, bilinear, cubic, etc.</li> <li><code>--gdal_translate</code> (str): Required if <code>--north-up</code>; path to <code>gdal_translate</code> binary. (Default: <code>gdal_translate</code>)</li> <li><code>--gdalwarp</code> (str): Required if <code>--north-up</code>; path to <code>gdalwarp</code> binary. (Default: <code>gdalwarp</code>)</li> </ul>"},{"location":"step_by_step/sge_harmonization/#output","title":"Output","text":"<p>Cartloader generates the following harmonized outputs:</p>"},{"location":"step_by_step/sge_harmonization/#unified-sge-matrix","title":"Unified SGE matrix","text":"<p>Both SGE conversion and density-based filtering generate a unified spatial gene expression (SGE) matrix, consisting of:</p> <ul> <li>A compressed transcript-indexed SGE file in TSV format.</li> <li>A TSV file for min and max X and Y coordinates.</li> <li>A TSV file collects UMI counts on a per-gene basis.</li> </ul>"},{"location":"step_by_step/sge_harmonization/#sge-images","title":"SGE Images","text":"<ul> <li>When <code>--sge-visual</code> is enabled, a monochrome PNG image is generated to visualize the SGE data.</li> <li>When <code>--north-up</code> is enabled, a georeferenced TIFF image is produced with a north-up orientation.</li> </ul>"}]}