import re, os, sys, shlex

class minimake:
    def __init__(self):
        # Dictionary to store the target as keys and a tuple of source files and commands as values
        self.targets = {}

    def add_target(self, target_file, source_files, commands):
        """
        Add a target with its dependencies and the commands to build it.

        :param target_file: String, the name of the target file
        :param source_files: List of strings, the source files the target depends on
        :param commands: List of strings, the commands needed to build the target
        """
        if target_file in self.targets:
            raise ValueError(f"Target {target_file} already exists.")
        self.targets[target_file] = (source_files, commands)
    
    # update 20250129: added a reusable func for both write_makefile and append_to_makefile
    def _write_targets(self, file, targets):
        """
        Writes target rules and associated commands into a Makefile.

        :param file: File object to write into.
        :param targets: Dictionary of targets and their dependencies/commands.
        """
        for target, (sources, commands) in targets.items():
            file.write(f"{target}: {' '.join(sources)}\n")
            for command in commands:
                    #update 20240807: Whenever the regex contains $, the Makefile cannot interpret $ properly because Make interprets special characters (used for referencing variables) and escapes them.
                    #                 To escape the $ character, updated the function to double it ($$) so that Make interprets it as a literal $ character.
                escaped_command = command if "$(info" in command else command.replace('$', '$$')
                file.write(f"\t{escaped_command}\n")
            file.write("\n")  # Add a newline for readability between targets


    def write_makefile(self, output_filename, use_bash=False):
        # update 20240812: added a use_bash parameter to allow /bin/bash as the shell for seqscope
        """
        Writes a Makefile with all added targets.

        :param output_filename: String, the path to the output Makefile
        """
        with open(output_filename, 'w') as file:
            file.write("# Makefile generated by minimake\n\n")
            if use_bash:
                file.write("SHELL := /bin/bash\n\n")
            file.write("all: " + " ".join(self.targets.keys()) + "\n\n")
            self._write_targets(file, self.targets)              

    # update 202501: added a new function to append new targets to an existing Makefile for testing purposes
    def append_to_makefile(self, output_filename, use_bash=False):
        """
        Appends new targets to an existing Makefile without overwriting existing content.
        If the Makefile does not exist, create a new one.
        """
        if not os.path.exists(output_filename):
            print(f"Makefile '{output_filename}' does not exist. Creating a new one instead.")
            self.write_makefile(output_filename, use_bash)
            return
        
        # Read existing Makefile
        with open(output_filename, "r") as file:
            lines = file.readlines()

        # Find the "all:" line and extract existing targets
        existing_targets, existig_lines, found_all = set(), [], False
        for line in lines:
            if line.startswith("all:"):
                if found_all:
                    raise ValueError(f"Multiple 'all:' targets in the existing makefile: '{output_filename}'.")
                found_all = True
                existing_targets.update(line.split(":")[1].strip().split())
                break  # Stop skipping lines before "all:"

        if not found_all:
            raise ValueError(f"No 'all:' target found in the existing makefile: '{output_filename}'.")

        existig_lines.extend(lines[lines.index(line) + 1 :])

        # targets
        new_targets = {target: self.targets[target] for target in self.targets if target not in existing_targets}
        if not new_targets:
            print("No new targets to append.")
            return

        all_targets = f"all: {' '.join(existing_targets | new_targets.keys())}\n\n"

        with open(output_filename, "w") as file:
            # headers
            file.write("# Makefile generated by minimake\n\n")
            if use_bash:
                file.write("SHELL := /bin/bash\n\n")
            file.write(all_targets)
            # each step
            file.writelines(existig_lines)
            file.write("\n")
            self._write_targets(file, new_targets)

        # print(f"New targets appended to {output_filename} and 'all' target updated.")

    # update 202501: added a new function to merge targets for testing purposes
    def merge_minimake(self, other):
        """
        Merge another minimake instance into this one.
        """
        for target, (sources, commands) in other.targets.items():
            if target not in self.targets:
                self.targets[target] = (sources, commands)

# Example usage
if __name__ == "__main__":
    create_source_files()
    mm = minimake()
    mm.add_target("program.exe", ["main.o", "utils.o"], ["gcc -o program.exe main.o utils.o"])
    mm.add_target("main.o", ["main.c", "utils.h"], ["gcc -c main.c"])
    mm.add_target("utils.o", ["utils.c", "utils.h"], ["gcc -c utils.c"])
    mm.write_makefile("Makefile")